---
export const prerender = true;
import Layout from "@/layouts/Layout.astro";
// import Card from "@/components/Card.astro";
import Dice from "@/components/projects/frogjump/dice.astro";
---

<Layout css_color_palette="dark_mode">
   <main>
      <!-- Instructions -->
      <h1>Instructions</h1>
      <p>
         You are a frog in a pond of 7 lily pads (numbered 0 to 6), and your
         goal is to escape the pond by getting to lily pad number 6. However,
         there is a snake at lily pad 0, patiently waiting for you to come to
         lily pad number 0. If you do land on lily pad 0, the snake opens its
         jaws and swallows you whole. You can pay 10 dollars and decide whether
         you start on the first or second lily pad, and you get 40 or 20 dollars
         respectively for successfully escaping the pond.
      </p>
      <p>
         In order to move the frog, you need to play a minigame that corresponds
         to the lily pad you are currently on. The minigames are:
      </p>

      <ul>
         <li>
            FATE. Shuffle the letters of FATE. If the A appears before the E,
            you move backwards. Otherwise, move forwards.
         </li>
         <li>
            You are dealt 4 cards. If you have exactly two cards of the same
            suit, move forwards. If none of the cards are the same suit, move
            backwards. Otherwise, reshuffle the deck and pick out 4 more cards.
         </li>
         <li>
            PROBABILITY. Shuffle the letters of PROBABILITY. If two B‚Äôs touch or
            two I‚Äôs touch, move forwards. Otherwise, move backwards.
         </li>
         <li>
            Roll two dice. If one die is a multiple of the other, move
            backwards. Otherwise, move forwards.
         </li>
         <li>
            Spin a spinner, with five tiles on RED and two tiles on BLUE (all
            tiles have equal size). If you land on a RED tile, move forward. If
            you land on a BLUE tile, move backwards.
         </li>
      </ul>

      <div class="betButtons">
         <button id="Bet1">Bet on Lily Pad 1</button>
         <button id="Bet2">Bet on Lily Pad 2</button>
      </div>
      <div class="gameButtons">
         <button id="Play">Play</button>
         <button id="Next">Next</button>
      </div>
      <div class="pond" id="pond">
         üêç Snake (LOSE) &larr;
         <img class="frog" src="/projects/frogjump/frog.png" id="frog" />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad0"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad1"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad2"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad3"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad4"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad5"
         />
         <img
            class="lilypad"
            src="/projects/frogjump/lily-pad.png"
            id="lilypad6"
         />
         &rarr; Leave Pond (WIN!)
      </div>

      <div id="Gamespace" class="gamespace">
         <div class="gameContainer">
            <!-- Separate the pond from the Games -->
            &nbsp;

            <!-- Game 1 -->
            <div class="game">
               <div class="game1 F1 game1i0" id="game1i0">F</div>
               <div class="game1 A1 game1i1" id="game1i1">A</div>
               <div class="game1 T1 game1i2" id="game1i2">T</div>
               <div class="game1 E1 game1i3" id="game1i3">E</div>
            </div>

            <!-- Game 2 -->
            <div class="game">
               <div class="game2card">
                  <img
                     class="backside"
                     id="game2backside0"
                     src="/projects/frogjump/cards/PNG/Small/Back Red 2.png"
                  />
                  <img class="frontside" id="game2i0" />
               </div>
               <div class="game2card">
                  <img
                     class="backside"
                     id="game2backside1"
                     src="/projects/frogjump/cards/PNG/Small/Back Red 2.png"
                  />
                  <img class="frontside" id="game2i1" />
               </div>
               <div class="game2card">
                  <img
                     class="backside"
                     id="game2backside2"
                     src="/projects/frogjump/cards/PNG/Small/Back Red 2.png"
                  />
                  <img class="frontside" id="game2i2" />
               </div>
               <div class="game2card">
                  <img
                     class="backside"
                     id="game2backside3"
                     src="/projects/frogjump/cards/PNG/Small/Back Red 2.png"
                  />
                  <img class="frontside" id="game2i3" />
               </div>
            </div>

            <!-- Game 3 -->
            <div class="game">
               <p id="game3i0" class="game3 P1 game3i0">P</p>
               <p id="game3i1" class="game3 R1 game3i1">R</p>
               <p id="game3i2" class="game3 O1 game3i2">O</p>
               <p id="game3i3" class="game3 B1 game3i3">B</p>
               <p id="game3i4" class="game3 B1 game3i4">A</p>
               <p id="game3i5" class="game3 A1 game3i5">B</p>
               <p id="game3i6" class="game3 B2 game3i6">I</p>
               <p id="game3i7" class="game3 L1 game3i7">L</p>
               <p id="game3i8" class="game3 I2 game3i8">I</p>
               <p id="game3i9" class="game3 T1 game3i9">T</p>
               <p id="game3i10" class="game3 Y1 game3i10">Y</p>
            </div>

            <!-- Game 4 -->
            <div class="game game4">
               <Dice />
            </div>
            <!-- Game 5 -->
            <div class="game5" id="game5">
               <img
                  style=""
                  class="spinnerMarker"
                  id="spinnerMarker"
                  src="/projects/frogjump/marker_dark_mode.png"
               />
               <img
                  class="spinner"
                  id="spinner"
                  src="/projects/frogjump/spinner.png"
               />
            </div>
         </div>
      </div>

      <p
         id="gameStatusElement"
         style="font-family: monospace; text-align: center;"
      >
         PENDING BET.
      </p>

      <a
         class="vecteezyattribution"
         href="https://www.vecteezy.com/free-vector/infographic-elements"
         >Infographic Elements Vectors by Vecteezy</a
      >
   </main>

   <style>
      .gamespace {
         border: solid 5px;
         margin: 2rem;
         justify-self: center;
         width: 100%;
         min-height: 60vh;
         max-width: 80%;
         display: flex;
         text-align: center;
         justify-content: center;
         align-items: center;
      }

      .gameContainer {
      }

      .frog,
      .lilypad {
         width: 2rem;
      }

      .frog {
         position: absolute;
         display: none;
      }

      .pond {
         /* width: 100%; */
         display: flex;
         /* position: relative; */
         align-self: center;
         justify-self: center;
      }

      .Games,
      .game {
         font-family: monospace;
         display: flex;
         justify-content: center;
         align-items: center;
      }

      .gameButtons,
      .betButtons {
         display: flex;
         column-gap: 1rem;
         justify-content: center;
         padding: 5px;
      }

      .game1,
      .game3 {
         display: none;
      }

      button {
         border: solid;
         padding: 5px;
      }

      /* Game specific */

      /* Game 2 */
      .game2card {
         display: none;
         position: relative;
         width: 47px;
         height: 62px;
      }

      .frontside,
      .backside {
         position: absolute;
         /* transform-style: preserve-3d; */
         /* transition: transform 1s; */
      }

      .game5 {
         /* flex-direction: row; */
         position: grid;
         align-items: center;
         place-items: center;
         justify-items: center;
      }

      .spinner {
         /* position: relative; */
         display: none;
      }

      .spinnerMarker {
         /* position: relative; */
         place-self: center;
         align-self: center;
         justify-self: center;
         display: none;
      }

      img {
         display: block;
         vertical-align: middle;
      }

      @media (orientation: portrait) {
         .game5 {
         }

         .spinnerMarker {
            /* I HAD to hardcode this. Mobile browsers just hate me that much. */
            left: 50%;
            position: relative;
            transform: translateX(-50%);
         }

         img {
            /* max-width: 80%; */
         }
      }

      .vecteezyattribution {
         /* margin-top: 100px; */
         font-size: 6px;
      }
   </style>
</Layout>

<script>
   import anime from "animejs/lib/anime.es.js";

   /**
    * Defines the game status.
    * This should contain the following information:
    * * which lily pad the player is currently on.
    * * the bet the player initially made (lily pad number).
    * * Whether or not a minigame is currently being played
    */
   let gameStatus = {
      pad: 0,
      bet: -1,
      preGame: placeholder,
      nextGame: placeholder,
      nextNext: placeholder,
      nextPressed: true,
   };
   let gameData = {
      0: null,
      1: {
         letters: ["F", "A", "T", "E"],
         elements: [
            document.getElementById("game1i0") as HTMLElement,
            document.getElementById("game1i1") as HTMLElement,
            document.getElementById("game1i2") as HTMLElement,
            document.getElementById("game1i3") as HTMLElement,
         ],
      },
      2: {
         backsides: [
            document.getElementById("game2backside0") as HTMLImageElement,
            document.getElementById("game2backside1") as HTMLImageElement,
            document.getElementById("game2backside2") as HTMLImageElement,
            document.getElementById("game2backside3") as HTMLImageElement,
         ],
         elements: [
            document.getElementById("game2i0") as HTMLImageElement,
            document.getElementById("game2i1") as HTMLImageElement,
            document.getElementById("game2i2") as HTMLImageElement,
            document.getElementById("game2i3") as HTMLImageElement,
         ],
         cards: document.querySelectorAll(".game2card"),
      },
      3: {
         letters: ["P", "R", "O", "B", "A", "B", "I", "L", "I", "T", "Y"],
         elements: [
            document.getElementById("game3i0") as HTMLElement,
            document.getElementById("game3i1") as HTMLElement,
            document.getElementById("game3i2") as HTMLElement,
            document.getElementById("game3i3") as HTMLElement,
            document.getElementById("game3i4") as HTMLElement,
            document.getElementById("game3i5") as HTMLElement,
            document.getElementById("game3i6") as HTMLElement,
            document.getElementById("game3i7") as HTMLElement,
            document.getElementById("game3i8") as HTMLElement,
            document.getElementById("game3i9") as HTMLElement,
            document.getElementById("game3i10") as HTMLElement,
         ],
      },
   };
   const defaultGameStatus = {
      pad: 0,
      bet: -1,
      preGame: placeholder,
      nextGame: placeholder,
      nextNext: placeholder,
      nextPressed: true,
   };
   /**
    * Pregame is a collection of functions called to make each game's elements visible.
    */
   let preGame = {
      0: placeholder,
      1: () => {
         document.querySelectorAll(".game1").forEach((value: Element) => {
            // reset translations
            (value as HTMLElement).style.transform = "none";
            (value as HTMLElement).dataset.translateX = "0";
            (value as HTMLElement).dataset.translateY = "0";

            // reset game data
            gameData[1] = {
               letters: ["F", "A", "T", "E"],
               elements: [
                  document.getElementById("game1i0") as HTMLElement,
                  document.getElementById("game1i1") as HTMLElement,
                  document.getElementById("game1i2") as HTMLElement,
                  document.getElementById("game1i3") as HTMLElement,
               ],
            };

            // make letters visible
            (value as HTMLElement).style.display = "initial";
         });
      },
      2: () => {
         // make cards visible
         // anime({
         //    targets: gameData[2].cards,
         //    duration: 250,
         //    loop: 1,
         // });
         gameData[2].cards.forEach((value: Element) => {
            (value as HTMLElement).style.display = "initial";
         });

         gameData[2].elements.forEach((value: HTMLImageElement) => {
            // value.style.transform = "rotateY(90)";
         });
         gameData[2].backsides.forEach((value: HTMLImageElement) => {
            // value.style.transform = "rotateY(0)";
         });
      },
      3: () => {
         // make letters visible
         document.querySelectorAll(".game3").forEach((value: Element) => {
            // make letters visible
            (value as HTMLElement).style.display = "initial";

            // reset translations
            (value as HTMLElement).style.transform = "none";
            (value as HTMLElement).dataset.translateX = "0";
            (value as HTMLElement).dataset.translateY = "0";

            // reset game data
            gameData[3] = {
               letters: ["P", "R", "O", "B", "A", "B", "I", "L", "I", "T", "Y"],
               elements: [
                  document.getElementById("game3i0") as HTMLElement,
                  document.getElementById("game3i1") as HTMLElement,
                  document.getElementById("game3i2") as HTMLElement,
                  document.getElementById("game3i3") as HTMLElement,
                  document.getElementById("game3i4") as HTMLElement,
                  document.getElementById("game3i5") as HTMLElement,
                  document.getElementById("game3i6") as HTMLElement,
                  document.getElementById("game3i7") as HTMLElement,
                  document.getElementById("game3i8") as HTMLElement,
                  document.getElementById("game3i9") as HTMLElement,
                  document.getElementById("game3i10") as HTMLElement,
               ],
            };
         });
      },
      4: () => {
         // make dice visible
         (
            document.querySelector(".diceContainer") as HTMLElement
         ).style.display = "flex";

         // make the dice roll go back to its default
         for (var k = 1; k <= 6; k++) {
            //@ts-ignore
            elDiceTwo.classList.remove("show-" + k);
            //@ts-ignore
            elDiceOne.classList.remove("show-" + k);
            if (1 === k) {
               //@ts-ignore
               elDiceTwo.classList.add("show-" + k);
               //@ts-ignore
               elDiceOne.classList.add("show-" + k);
            }
         }
      },
      5: () => {
         // show spinner
         if (spinner != null) {
            spinner.style.display = "block";
         }
         // show marker
         if (spinnerMarker != null) {
            spinnerMarker.style.display = "block";
         }
      },
      6: placeholder,
   };
   /**
    * This contains all the game functions, which process game logic.
    */
   let gameFunctions = {
      0: placeholder,
      1: firstLilyPad,
      2: secondLilyPad,
      3: thirdLilyPad,
      4: fourthLilyPad,
      5: fifthLilyPad,
      6: placeholder,
   };
   /**
    * This contains the functions that hide game elements after the game is over.
    */
   let nextFunctions = {
      0: placeholder,
      1: () => {
         // reset letter positions and hide letters
         document.querySelectorAll(".game1").forEach((value: Element) => {
            (value as HTMLElement).style.display = "none"; // hide
         });
      },
      2: () => {
         // flip back over
         anime({
            targets: gameData[2].elements,
            rotateY: [360, -270],
            duration: 1000,
            loop: 1,
         });
         anime({
            targets: gameData[2].backsides,
            rotateY: [90, 0],
            duration: 1000,
            loop: 1,
            // complete: function () {
            //    gameData[2].cards.forEach((value: Element) => {
            //       (value as HTMLElement).style.display = "none";
            //    });
            // },
         });

         gameData[2].cards.forEach((value: Element) => {
            (value as HTMLElement).style.display = "none";
         });
      },
      3: () => {
         // reset letter positions and hide letters
         document.querySelectorAll(".game3").forEach((value: Element) => {
            (value as HTMLElement).style.display = "none"; // hide
         });
      },
      4: () => {
         // hide dice
         (
            document.querySelector(".diceContainer") as HTMLElement
         ).style.display = "none";
      },
      5: () => {
         // hide spinner
         if (spinner != null) {
            spinner.style.display = "none";
         }

         // reset spinner rotation
         anime({
            targets: spinner,
            rotateZ: 0,
            duration: 0,
         });

         // hide marker
         if (spinnerMarker != null) {
            spinnerMarker.style.display = "none";
         }

         if (gameStatus.bet == -1) { // if the last game was over,
            // hide the frog
            (frog as HTMLElement).style.display = "none";
         }
      },
      6: placeholder,
   };
   /**
    * Win messages based on your current lily pad number.
    * To elaborate, you have just won the game, and now you are on lily pad #[KEY].
    */
   const winMessages = {
      0: "PENDING BET.",
      1: "Wow. The game logic really did blow up, huh?",
      2: "You won! You move to lily pad 2.",
      3: "You won! You move to lily pad 3.",
      4: "You won! You move to lily pad 4.",
      5: "You won! You move to lily pad 5.",
      6: "You won! You move to lily pad 6. YOU WON THE BET!!!",
   };
   const lossMessages = {
      0: "You lost! You move to lily pad 0. The snake LEAPS at you, swallowing you whole before you could even close your eyes.",
      1: "You lost! You move to lily pad 1.",
      2: "You lost! You move to lily pad 2.",
      3: "You lost! You move to lily pad 3.",
      4: "You lost! You move to lily pad 4.",
      5: "You lost! You move to lily pad 5.",
   };
   const tieMessages = {
      0: "PENDING BET.",
      1: "Wow. The game logic really did blow up, huh?",
      2: "You tied! You stay on lily pad 2.",
      3: "Wow. The game logic really did blow up, huh?",
      4: "Wow. The game logic really did blow up, huh?",
      5: "Wow. The game logic really did blow up, huh?",
      6: "Wow. The game logic really did blow up, huh?",
   };

   /**
    * Variable containing the element that outputs messages to the user in text.
    */
   let gameStatusElement = document.getElementById("gameStatusElement");

   // Deck related variables
   const cardFilePath = "/projects/frogjump/cards/PNG/Small/";
   const cardFileExtension = ".png";

   type Card = {
      suit: string;
      imageFilePath: string;
   };
   // END Deck related variables

   /**
    * Contains information relating to all cards. Links their numerical ID to a file path and whatnot.
    */
   const cardData: Record<number, Card> = {
      1: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 1" + cardFileExtension,
      },
      2: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 2" + cardFileExtension,
      },
      3: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 3" + cardFileExtension,
      },
      4: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 4" + cardFileExtension,
      },
      5: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 5" + cardFileExtension,
      },
      6: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 6" + cardFileExtension,
      },
      7: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 7" + cardFileExtension,
      },
      8: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 8" + cardFileExtension,
      },
      9: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 9" + cardFileExtension,
      },
      10: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 10" + cardFileExtension,
      },
      11: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 11" + cardFileExtension,
      },
      12: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 12" + cardFileExtension,
      },
      13: {
         suit: "Clubs",
         imageFilePath: cardFilePath + "Clubs 13" + cardFileExtension,
      },
      14: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 1" + cardFileExtension,
      },
      15: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 2" + cardFileExtension,
      },
      16: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 3" + cardFileExtension,
      },
      17: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 4" + cardFileExtension,
      },
      18: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 5" + cardFileExtension,
      },
      19: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 6" + cardFileExtension,
      },
      20: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 7" + cardFileExtension,
      },
      21: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 8" + cardFileExtension,
      },
      22: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 9" + cardFileExtension,
      },
      23: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 10" + cardFileExtension,
      },
      24: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 11" + cardFileExtension,
      },
      25: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 12" + cardFileExtension,
      },
      26: {
         suit: "Diamond",
         imageFilePath: cardFilePath + "Diamond 13" + cardFileExtension,
      },
      27: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 1" + cardFileExtension,
      },
      28: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 2" + cardFileExtension,
      },
      29: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 3" + cardFileExtension,
      },
      30: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 4" + cardFileExtension,
      },
      31: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 5" + cardFileExtension,
      },
      32: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 6" + cardFileExtension,
      },
      33: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 7" + cardFileExtension,
      },
      34: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 8" + cardFileExtension,
      },
      35: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 9" + cardFileExtension,
      },
      36: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 10" + cardFileExtension,
      },
      37: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 11" + cardFileExtension,
      },
      38: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 12" + cardFileExtension,
      },
      39: {
         suit: "Hearts",
         imageFilePath: cardFilePath + "Hearts 13" + cardFileExtension,
      },
      40: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 1" + cardFileExtension,
      },
      41: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 2" + cardFileExtension,
      },
      42: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 3" + cardFileExtension,
      },
      43: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 4" + cardFileExtension,
      },
      44: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 5" + cardFileExtension,
      },
      45: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 6" + cardFileExtension,
      },
      46: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 7" + cardFileExtension,
      },
      47: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 8" + cardFileExtension,
      },
      48: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 9" + cardFileExtension,
      },
      49: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 10" + cardFileExtension,
      },
      50: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 11" + cardFileExtension,
      },
      51: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 12" + cardFileExtension,
      },
      52: {
         suit: "Spades",
         imageFilePath: cardFilePath + "Spades 13" + cardFileExtension,
      },
   };

   // elements
   let elDiceOne = document.getElementById("dice1");
   let elDiceTwo = document.getElementById("dice2");
   let spinner = document.getElementById("spinner");
   let spinnerMarker = document.getElementById("spinnerMarker");
   let frog = document.getElementById("frog");

   // buttons and event listeners
   let playButton = document.getElementById("Play");
   playButton?.addEventListener("click", playNextGame);

   function onBetButtonClick(padNumber: number) {
      // ensure valid input
      if (padNumber != 1 && padNumber != 2) return;

      // make sure ther is no bet active
      if (gameStatus.pad != 0 && gameStatus.pad != 6) {
         return;
      }

      if (
         gameStatus.nextPressed === false &&
         gameStatus.nextNext != placeholder
      ) {
         gameStatus.nextNext(); // clear up stuff from the last game
      }

      gameStatus = {
         pad: padNumber,
         bet: padNumber,
         preGame: preGame[padNumber],
         nextGame: gameFunctions[padNumber],
         nextNext: nextFunctions[padNumber],
         nextPressed: true,
      };

      if (gameStatusElement != null) {
         gameStatusElement.innerHTML =
            "You bet on lily pad #" + padNumber + ".";
      }

      // position frog correctly
      if (frog != null) {
         (frog as HTMLElement).style.display = "unset";
         jumpTo(gameStatus.pad, false);
      }

      // hide bet buttons
      try {
         (document.querySelector(".betButtons") as HTMLElement).style.display =
            "none";
      } catch {}

      gameStatus.preGame();
   }

   let betButtons = [
      document.getElementById("Bet1"),
      document.getElementById("Bet2"),
   ];
   betButtons[0]?.addEventListener("click", onBetButtonClick.bind(null, 1));
   betButtons[1]?.addEventListener("click", onBetButtonClick.bind(null, 2));

   let nextButton = document.getElementById("Next");
   nextButton?.addEventListener("click", next);
   // END: buttons and event listeners

   function postGame(nextFunction: () => any): void {
      // start playing the jumping animation.
      jumpTo(gameStatus.pad, true);

      // reset game
      gameStatus = defaultGameStatus;

      gameStatus.nextPressed = false; // let the onBetButtonClicked function know that they need to reset the game area.

      // enable the ability to hide the game area stuff relating to the last lily pad visited
      gameStatus.nextNext = nextFunction;

      // show bet buttons
      try {
         (document.querySelector(".betButtons") as HTMLElement).style.display =
            "flex";
      } catch {}
   }

   function playNextGame() {
      switch (gameStatus.pad) {
         case 0: // the game hasn't started yet
            if (!gameStatus.nextPressed) {
               // if the user didn't press the next button to hide the last game's elements,
               gameStatus.nextNext();
               gameStatus.nextNext = placeholder; // prevent the user from pressing the button again.
            }

            if (gameStatusElement != null) {
               gameStatusElement.innerHTML = "PENDING BET.";
            }
            return;
         case 1:
            break;
         case 2:
            break;
         case 3:
            break;
         case 4:
            break;
         case 5:
            break;
         default:
            return;
      }

      // force the nextGame function to be defined
      if (gameStatus.nextGame == undefined) return;
      // if the player didn't press the next button already, do it for them.
      if (gameStatus.nextPressed === false) {
         // console.log(
         //    "Automatically pressing the next button since the user didn't already do so!",
         // );
         gameStatus.nextNext();
         gameStatus.preGame();
      }
      let win = gameStatus.nextGame();

      // REQUIRE next button be pressed.
      gameStatus.nextPressed = false;
      gameStatus.nextNext = nextFunctions[gameStatus.pad];

      // console.log("Game status BEFORE: ", gameStatus);
      // console.log("Pad number BEFORE: ", gameStatus.pad);
      // win/loss logic
      win = true;
      if (win === true) {
         // win
         gameStatus.pad++;

         // show win message
         if (gameStatusElement != null) {
            //@ts-ignore I know for a FACT that 6 is fine.
            gameStatusElement.innerHTML = winMessages[gameStatus.pad];
         }

         // if the player has successfully won the game,
         if (gameStatus.pad == 6) {
            postGame(nextFunctions[5]);
            return; // avoid new game functions being set
         }
      } else if (win === false) {
         // loss
         gameStatus.pad--;

         if (gameStatusElement != null) {
            //@ts-ignore I know for a FACT that 0 is fine.
            gameStatusElement.innerHTML = lossMessages[gameStatus.pad];
         }

         // COMPLETE loss; the frog has been eaten by the snake
         if (gameStatus.pad == 0) {
            postGame(nextFunctions[1]);
            return; // avoid new game functions being set
         }
      } else {
         // tie or requires a replay, and additionally where the placeholder function call goes
         if (gameStatusElement != null) {
            gameStatusElement.innerHTML = tieMessages[gameStatus.pad];
         }
      }

      // start playing the jumping animation
      jumpTo(gameStatus.pad, true);

      // console.log("Game status AFTER: ", gameStatus);
      // console.log("Pad number AFTER: ", gameStatus.pad);
      //@ts-ignore I know for a FACT that 0 and 6 are fine.
      gameStatus.nextGame = gameFunctions[gameStatus.pad];
      //@ts-ignore
      gameStatus.preGame = preGame[gameStatus.pad];
   }

   function placeholder(): any {
      const message = "PENDING BET. PLEASE CLICK ON BET.";
      // console.log("A placeholder function has been called.");
      if (gameStatusElement != null) {
         gameStatusElement.innerHTML = "PENDING BET. PLEASE CLICK ON BET.";
      }

      return;
   }

   /**
    * Called when the next button is pressed.
    */
   function next() {
      // force the function to be called to be defined
      if (gameStatus.nextNext == undefined) return;
      gameStatus.nextNext();
      gameStatus.preGame();

      gameStatus.nextPressed = true;

      if (gameStatusElement != null) {
         gameStatusElement.innerHTML = "";
      }
   }

   // MINIGAME LOGIC
   /**
    * Plays the game and animations for a lily pad's game.
    * Returns the next function of the next lily pad OR returns a placeholder function and immediately executes win/loss code.
    */
   function firstLilyPad() {
      // game logic
      let gameResult = gameData[1].letters; // pass in by REFERENCE
      shuffleLetters(gameResult, gameData[1].elements);

      // if the index of the A is smaller than the E,
      // that means that the A is before the E,
      // which means that the player loses.
      if (
         gameResult.findIndex((element) => element == "A") <
         gameResult.findIndex((element) => element == "E")
      ) {
         // loss
         return false;
      } else {
         // win
         return true;
      }
   }

   function secondLilyPad() {
      // game logic

      // pick, at random, 4 cards from the deck.
      let deck: Array<number> = [];
      for (let i = 0; i < 52; i++) {
         deck[i] = i + 1;
      }

      // shuffle deck
      for (let i = deck.length - 1; i >= 0; i--) {
         let j = Math.ceil(Math.random() * (52 - i));

         let temp = deck[i];
         deck[i] = deck[j];
         deck[j] = temp;
      }

      // take top 4 cards from deck
      const pickedCards: Array<number> = [deck[0], deck[1], deck[2], deck[3]];

      // add card images
      for (let i = 0; i < gameData[2].elements.length; i++) {
         gameData[2].elements[i].src = cardData[pickedCards[i]].imageFilePath;
      }

      // animate turning the cards over
      anime({
         targets: gameData[2].elements,
         rotateY: [-270, 360],
         // duration: 1000,
         loop: 1,
      });
      anime({
         targets: gameData[2].backsides,
         rotateY: [0, 90],
         // duration: 1000,
         loop: 1,
      });

      // count the number of cards in each suit
      let numberOfSuits = {
         Clubs: 0,
         Diamond: 0,
         Hearts: 0,
         Spades: 0,
      };
      for (let i of pickedCards) {
         //@ts-ignore HOPEFULLY DOES NOT CAUSE ERRORS, just make sure the deck constant is OK
         numberOfSuits[cardData[i].suit]++;
      }

      // if all the cards are in different suits,
      if (
         numberOfSuits["Clubs"] == 1 &&
         numberOfSuits["Diamond"] == 1 &&
         numberOfSuits["Hearts"] == 1 &&
         numberOfSuits["Spades"] == 1
      ) {
         // loss
         return false;
      } else if (
         (function winCondition() {
            // remember that exactly TWO cards have to be in the same suit in order to win.
            // This means that having 3 cards in the same suit will result in a tie, and having 2 cards as the same suit but 2 cards in another suit will also result in a tie.
            let numTwoCards: number = 0;
            //@ts-ignore numberOfSuits ONLY has strings as keys, as defined earlier.
            for (let i in numberOfSuits) {
               //@ts-ignore
               if (numberOfSuits[i] == 2) numTwoCards++;
            }
            return numTwoCards == 1;
         })()
      ) {
         // win
         return true;
      }
   }

   function thirdLilyPad() {
      // game logic
      let gameResult = gameData[3].letters;
      shuffleLetters(gameResult, gameData[3].elements);

      // if two letters are one index away from each other,
      // they must be touching.
      // The player loses if two letters are touching.
      let Bs = [gameResult.indexOf("B")];
      Bs.push(gameResult.indexOf("B", Bs[0] + 1)); // this will NEVER error given that there are two B's in PROBABILITY
      let Is = [gameResult.indexOf("I")];
      Is.push(gameResult.indexOf("I", Is[0] + 1));
      if (Math.abs(Bs[0] - Bs[1]) == 1 || Math.abs(Is[0] - Is[1]) == 1) {
         // loss
         return false;
      } else {
         // win
         return true;
      }
   }

   function fourthLilyPad() {
      let gameResult = rollDice();
      // console.log(
      //    "Game result of game 4: ",
      //    gameResult,
      //    ", ",
      //    gameResult[0] % gameResult[1],
      //    ", ",
      //    gameResult[1] % gameResult[0],
      // );

      // if one die is a multiple of the other,
      // AKA if the first die is a multiple of the second die OR the second die is a multiple of the first die,
      if (
         gameResult[0] % gameResult[1] == 0 ||
         gameResult[1] % gameResult[0] == 0
      ) {
         return false;
      } else {
         // the win condition is to not lose! :D
         return true;
      }
   }

   function fifthLilyPad() {
      let rollNumber = Math.floor(Math.random() * 7 + 1);
      if (rollNumber == 7) {
         rollNumber = 1;
      } // avoid this edge case. IDK what's up with JS nowadays.

      // start playing animation before returning the result
      anime({
         targets: spinner,
         rotateZ: function () {
            let output = [
               0,
               // so apparently rotating should be backwards because people like rotating things counterclockwise. That's why the -1 multiplier is there.
               -1 *
                  anime.random(
                     // 360/7 is the degrees rotated in order to rotate by one regionn.
                     // 1 is the wiggle room; I don't want the spinner to be too close to the edge because this spinner image has very thick edges.
                     (360 / 7) * (rollNumber - 1) + 1,
                     (360 / 7) * rollNumber - 1,
                  ),
            ];
            return output;
         },
         easing: "easeOutQuad",
         duration: 2000,
      });

      // you win if you land on region 1 or 4, starting from vertical position (N),
      switch (rollNumber) {
         case 1: // curse javascript stupid syntax! XD
         case 4:
            return true;
         default:
            return false;
      }
   }
   // END: MINIGAME LOGIC

   /**
    * Shuffles letters, displays their animations, and returns the final result.
    * NOTE: passing in the array by reference makes it so that you don't have to store the return value of this function.
    * @param letters: An array with pairs of letters and nodes.
    * Coded with logic pulled from https://dev.to/codebubb/how-to-shuffle-an-array-in-javascript-2ikj
    */
   function shuffleLetters(letters: Array<String>, nodes: Array<HTMLElement>) {
      // ensure valid input
      if (letters.length != nodes.length) return;

      // constant
      const singleShuffleLength = 2000 / letters.length;

      let tl = anime.timeline({
         duration: singleShuffleLength * letters.length,
         // autoplay: false,
      });

      for (let i = letters.length - 1; i >= 0; i--) {
         let j = Math.floor(Math.random() * (i + 1));

         // Swap values at i and j, the randomly generated location.
         if (i == j) {
            // console.log("Skipping...");
            continue;
         }

         // console.log(
         //    "Swap ",
         //    letters[i],
         //    " with ",
         //    letters[j],
         //    "(",
         //    i,
         //    ", ",
         //    j,
         //    ")",
         // );
         let temp = letters[i];
         letters[i] = letters[j];
         letters[j] = temp;

         let temp2 = nodes[i];
         nodes[i] = nodes[j];
         nodes[j] = temp2;

         if (letters[i] === null) {
            console.log("OH SHIT! TYPE ERROR.");
            continue;
         }

         // animate this swap
         let iElementTemp = nodes[j];
         let jElementTemp = nodes[i];
         if (iElementTemp == null || jElementTemp == null) continue;
         let iElement: HTMLElement = iElementTemp as HTMLElement;
         let jElement: HTMLElement = jElementTemp as HTMLElement;

         // NOTE: the indexes for this are different compared to the other function that has a similar animation, the frog jumping one.
         let initialPositions: Array<[number, number]> = [
            [
               iElement.getBoundingClientRect().left,
               jElement.getBoundingClientRect().left,
            ],
            [
               iElement.getBoundingClientRect().top,
               jElement.getBoundingClientRect().top,
            ],
         ];
         // console.log(
         //    "Initial positions before translations: ",
         //    initialPositions,
         // );

         if (iElement.dataset.translateX != null)
            initialPositions[0][0] += parseInt(iElement.dataset.translateX);
         if (jElement.dataset.translateX != null)
            initialPositions[0][1] += parseInt(jElement.dataset.translateX);
         if (iElement.dataset.translateY != null)
            initialPositions[1][0] += parseInt(iElement.dataset.translateY);
         if (jElement.dataset.translateY != null)
            initialPositions[1][1] += parseInt(jElement.dataset.translateY);

         // console.log("Initial Positions: ", initialPositions);
         tl.add({
            targets: iElement,
            translateY: function (
               element: any,
               index: number,
               targetsLength: number,
            ) {
               // j's initial y coordinate - i's initial y coordinate
               // Delta (change) = final - initial
               // remember to also include the element.translateY to modify rather than completely override the value
               let output = initialPositions[1][1] - initialPositions[1][0];
               if (element.dataset.translateY != undefined)
                  output += parseInt(element.dataset.translateY);
               // console.log("i translateY: ", output);
               element.dataset.translateY = output;
               return output;
            }, // how many array elements does this guy move backwards or forwards?
            translateX: function (
               element: any,
               index: number,
               targetsLength: number,
            ) {
               let output = initialPositions[0][1] - initialPositions[0][0];
               if (element.dataset.translateX != undefined)
                  output += parseInt(element.dataset.translateX);
               // console.log("i translateX: ", output);
               element.dataset.translateX = output;
               return output;
            }, // how many array elements does this guy move backwards or forwards?
            // direction: "reverse",
            duration: singleShuffleLength,
         });

         tl.add(
            {
               targets: jElement,
               translateY: function (
                  element: any,
                  index: number,
                  targetsLength: number,
               ) {
                  let output = initialPositions[1][0] - initialPositions[1][1];
                  if (element.dataset.translateY != undefined)
                     output += parseInt(element.dataset.translateY);
                  // console.log("j translateY: ", output);
                  element.dataset.translateY = output;
                  return output;
               },
               translateX: function (
                  element: any,
                  index: number,
                  targetsLength: number,
               ) {
                  let output = initialPositions[0][0] - initialPositions[0][1];
                  if (element.dataset.translateX != undefined)
                     output += parseInt(element.dataset.translateX);
                  // console.log("j translateX: ", output);
                  element.dataset.translateX = output;
                  return output;
               },
               // direction: "reverse",
               duration: singleShuffleLength,
            },
            "-=" + singleShuffleLength,
         ); // offset of zero---the cards start swapping at the same time
      }

      // console.log("Done shuffling letters: ", letters);
      return letters;
   }

   // DICE ROLL LOGIC:
   /**
    * Rolls the dice while playing an animation for them. I did not write this code or the animation code.
    * This was made thanks to Lena Stanley on codepen.io: https://codepen.io/lenasta92579651/pen/yLeVmdW.
    */
   function rollDice() {
      var diceOne = Math.floor(Math.random() * 6 + 1);
      var diceTwo = Math.floor(Math.random() * 6 + 1);

      for (var i = 1; i <= 6; i++) {
         //@ts-ignore
         elDiceOne.classList.remove("show-" + i);
         if (diceOne === i) {
            //@ts-ignore
            elDiceOne.classList.add("show-" + i);
         }
      }

      for (var k = 1; k <= 6; k++) {
         //@ts-ignore
         elDiceTwo.classList.remove("show-" + k);
         if (diceTwo === k) {
            //@ts-ignore
            elDiceTwo.classList.add("show-" + k);
         }
      }

      return [diceOne, diceTwo];
   }
   // END: DICE ROLL LOGIC

   // START: Frog Jump Logic (lol)
   function jumpTo(pad: number, displayAnimation: boolean): void {
      let targetPadDummy = document.getElementById("lilypad" + pad);
      let frogDummy = document.getElementById("frog");
      // WARNING: the below line is vulnerable to DOM changes by the user (but usually there's not much we can do about it)
      let parentContainerDummy = document.getElementById("pond");

      if (
         targetPadDummy == null ||
         frogDummy == null ||
         parentContainerDummy == null
      ) {
         // if the input is invalid or someone REALLY messed with the DOM tree,
         return;
      }
      let targetPad: HTMLElement = targetPadDummy;
      let frog: HTMLElement = frogDummy;
      let parentContainer: HTMLElement = parentContainerDummy;

      let initialPositions: Array<[number, number]> = [
         [
            targetPad.getBoundingClientRect().left,
            targetPad.getBoundingClientRect().top,
         ],
         [
            parentContainer.getBoundingClientRect().left,
            parentContainer.getBoundingClientRect().top,
         ],
      ];
      console.log("Initial positions before translations: ", initialPositions);

      if (targetPad.dataset.translateX != null) {
         initialPositions[0][0] += parseInt(targetPad.dataset.translateX);
      }
      if (targetPad.dataset.translateY != null) {
         initialPositions[0][1] += parseInt(targetPad.dataset.translateY);
      }
      if (frog.dataset.translateX != null) {
         initialPositions[1][0] += parseInt(frog.dataset.translateX);
      }
      if (frog.dataset.translateY != null) {
         initialPositions[1][1] += parseInt(frog.dataset.translateY);
      }

      let translateFrogX = initialPositions[0][0] - initialPositions[1][0];
      if (frog.dataset.translateX != undefined)
         translateFrogX += parseInt(frog.dataset.translateX);
      // console.log("frog translateX: ", translateFrogX);
      frog.dataset.translateX = translateFrogX.toString();
      let translateFrogY = initialPositions[0][1] - initialPositions[1][1];
      translateFrogY = initialPositions[0][1] - initialPositions[1][1];
      if (frog.dataset.translateY != undefined)
         translateFrogY += parseInt(frog.dataset.translateY);
      // console.log("frog translateY: ", translateFrogY);
      frog.dataset.translateY = translateFrogY.toString();

      anime({
         targets: frog,
         loop: false,
         duration: function() {
            if (displayAnimation) {
               return 250; // 3/4ths of a second
            } else {
               return 0;
            }
         },
         translateX: [
            {
               value: function () {
                  return translateFrogX;
               },
               // easing: "linear",
               easing: "easeInQuad",
            },
         ],
         // translateY: [
         //    {
         //       value: function () {
         //          return translateFrogY - 10;
         //       },
         //       easing: "easeInQuad",
         //    },
         //    {
         //       value: translateFrogY,
         //       easing: "easeInQuad",
         //    },
         // ],
      });
   }
</script>
