---
interface Props {
    chartID: string;
    datapoints: string[];
    datasetTypes: string[];
    datasetTypesLabel: string;
}

let { chartID, datapoints, datasetTypes, datasetTypesLabel } = Astro.props;

let charts = {};
let thisChartID = chartID; // I want to avoid duping variable names :P
---

<button id={chartID + " regenerateChart"}>Regenerate Chart</button>
<table style="border-collapse: collapse;">
    <thead>
        <tr>
            <th style="border-bottom: solid 2px black;">Chart Settings</th>
            <th
                style="border-bottom: solid 2px black;border-left: solid 2px black;"
                >Chart</th
            >
        </tr>
    </thead>
    <tbody>
        <tr>
            <th style="text-align: left;">
                <div id={chartID + " select"}>
                    <p>Chart type:</p>
                    <select id={chartID + " chart type"}>
                        <option value="bar">Bar</option>
                        <option value="scatter">Scatter Plot</option>
                    </select>
                    <br />
                    <br />

                    <p>Datasets:</p>
                    <button
                        id={chartID + " selectAll"}
                        type="button">Select All</button
                    >
                    {
                        datapoints.map((datum: string) => {
                            return (
                                <>
                                    <br />
                                    <input type="checkbox" id={datum} />
                                    <label for={datum}>{datum}</label>
                                </>
                            );
                        })
                    }
                    <br />
                    <br />

                    <p>Sort By Trial:</p>
                    <select name={chartID + " sortBy"} id={chartID + " sortBy"}>
                        {
                            datapoints.map((datum: string) => {
                                return <option value={datum}>{datum}</option>;
                            })
                        }
                    </select>
                    <p>{datasetTypesLabel}</p>
                    <select
                        name={chartID + " algorithm"}
                        id={chartID + " algorithm"}
                    >
                        {datasetTypes.map((i: string) => {
                            return <option value={i}>{i}</option>
                        })}
                    </select>
                </div>
            </th>
            <th style="width:100%;border-left: solid 2px black;"
                ><canvas id={chartID} class="chart"></canvas>
            </th>
        </tr>
    </tbody>
</table>

<script is:inline define:vars={{ charts, thisChartID }}>
    document.getElementById(thisChartID + " regenerateChart").addEventListener("click", () => {chart(thisChartID)});
    document.getElementById(thisChartID + " selectAll").addEventListener("click", () => {selectAll(thisChartID);console.log("lol");});

    // returns [[all names], [[labels, runtime], [labels, runtime], ...], [[labels, runtime], [labels, runtime], ...], ...] or an empty array given an error
    async function getChartData(trialIDs, trialIDToSortBy, algorithmName) {
        try {
            let output = [[]];
            // create empty array with sufficient length
            for (let a = 0; a < trialIDs.length; a++) {
                output.push([[], []]);
            }

            let trialIDsString = "";

            for (const i of trialIDs) {
                trialIDsString += "," + i;
            }
            trialIDsString = trialIDsString.substring(1, trialIDsString.length);

            let response = await fetch(
                "/projects/rpsruntime/chart" +
                    "?trialID=" +
                    trialIDsString +
                    "&sortBy=" +
                    trialIDToSortBy +
                    "," +
                    algorithmName,
                {
                    method: "GET",
                },
            );

            let dataIn = await response.json();
            let contentIn = dataIn["content"];

            // traverse through data
            for (const i of contentIn) {
                // record name
                output[0].push(i["name"]);
                for (let a = 0; a < trialIDs.length; a++) {
                    // order should be correct already when passing into this function, do not worry about order.
                    output[a + 1][0].push(
                        "Runtime Ascending Order Trial " + trialIDs[a],
                    );
                    output[a + 1][1].push(i[trialIDs[a]][algorithmName]);
                }
            }
            console.log(output);

            return output;
        } catch (error) {
            console.error(`ERROR: ${error.message}\n\nGraph will now be empty`);
            return [];
        }
    }

    // returns the chart that has been set
    async function setChart(
        trialIDs,
        trialIDToSortBy,
        algorithmName,
        chartElement,
        chartType,
    ) {
        let dataIn = await getChartData(
            trialIDs,
            trialIDToSortBy,
            algorithmName,
        );
        let chartDatasets = [];
        for (let i = 1; i < dataIn.length; i++) {
            chartDatasets.push({
                label: "Runtime Ascending Order Trial " + trialIDs[i - 1],
                data: dataIn[i][1],
                borderWidth: 1,
            });
        }

        console.log(chartDatasets);

        return await new Chart(chartElement, {
            type: chartType,
            data: {
                labels: dataIn[0],
                datasets: chartDatasets,
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                    },
                },
            },
        });
    }

    async function chart(id) {
        try {
            charts[id].destroy();
        } catch (error) {} // delete a chart if it's already there so a new one may be generated

        let trialIDs = [];
        let elements = document.getElementById(id + " select").children;
        for (const i of elements) {
            if (i.checked == true) {
                trialIDs.push(i.id);
            }
        }

        if (trialIDs.length == 0) {
            // Abort if there are no datasets
            return;
        }

        console.log(document.getElementById(id + " algorithm").value);
        charts[id] = await setChart(
            trialIDs,
            document.getElementById(id + " sortBy").value,
            document.getElementById(id + " algorithm").value,
            document.getElementById(id),
            document.getElementById(id + " chart type").value,
        );
    }

    function selectAll(id) {
        let elements = document.getElementById(id + " select").children;
        for (const i of elements) {
            if (i.type == "checkbox") {
                i.checked = true;
            }
        }
    }
</script>
